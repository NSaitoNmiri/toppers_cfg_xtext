/*
 * generated by Xtext 2.17.0
 */
package jp.toppers.cfg.validation

import com.google.inject.Inject
import java.util.regex.Pattern
import jp.toppers.cfg.cfg.C_Directive
import jp.toppers.cfg.cfg.C_IncludeLine
import jp.toppers.cfg.cfg.CfgPackage
import org.eclipse.xtext.nodemodel.INode
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.resource.ILocationInFileProvider
import org.eclipse.xtext.validation.Check
import java.util.Objects
import jp.toppers.cfg.cfg.CfgFile

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class CfgValidator extends AbstractCfgValidator {

	protected static val ISSUE_CODE_PREFIX = "jp.toppers.cfg.";
	public static val NO_BOL_SHARP = ISSUE_CODE_PREFIX + "NoBolSharp";
	public static val NO_EOL_NL = ISSUE_CODE_PREFIX + "NoEolNl";
	public static val EXTRA_NL_IN_CDIRECTIVE = ISSUE_CODE_PREFIX + "ExtraNlInCDirective";
	public static val EXTRA_NL_IN_CINCLUDE = ISSUE_CODE_PREFIX + "ExtraNlInCInclude";
	public static val EXTRA_SPC_IN_CINCLUDE_NAME = ISSUE_CODE_PREFIX + "ExtraSpcInCIncludeName";

	@Inject extension ILocationInFileProvider

	@Check
	def checkSharpIsBeginningOfLine(C_Directive directive) {
		var fnode = NodeModelUtils.getNode(directive.eContainer) as INode
		var fileStr = fnode.text
		var r = directive.fullTextRegion

		if(r.offset > 0) {
			var si = fileStr.lastIndexOf('\n', r.offset-1)
			if(si < 0) {
				si = 0
			}
			var substr = fileStr.substring(si, r.offset);
			var pattern = Pattern.compile("\\S", Pattern.COMMENTS)
			var matcher = pattern.matcher(substr)
			if(matcher.find) {
				error("'#' is not the beginning of line.",
					CfgPackage.eINSTANCE.c_Directive_Sharp,
					NO_BOL_SHARP,
					fileStr.substring(r.offset, r.offset+r.length))
			}
		}
	}
	
	@Check
	def checkNewLineIsEndOfLine(C_Directive directive) {
		if (directive.cr1){ return }
		if (directive.s_comment) {return}
		if (Objects.nonNull(directive.m_comment)) {
			if(directive.m_comment.contains('\n')) {
				return
			}
		}
		for (e : directive.eols) {
			if(e.contains('\n')) {
				return
			}
		}

		var file = directive.eContainer as CfgFile
		var fnode = NodeModelUtils.getNode(file) as INode
		var fText = fnode.text
		var dRegion = directive.fullTextRegion
		var dNextOfs = dRegion.offset + dRegion.length

		error("new-line charactor is required at the end of C preprosessor directives.",
			CfgPackage.eINSTANCE.c_Directive_Line,
			NO_EOL_NL,
			fText.substring(dRegion.offset, dNextOfs))
	}	

	@Check
	def checkNoExtraNewLineInCDirective(C_Directive directive) {
		var fnode = NodeModelUtils.getNode(directive.eContainer) as INode
		var fileStr = fnode.text

		var node = NodeModelUtils.getNode(directive) as INode
		var nodeStr = node.text

		var sofs = nodeStr.indexOf(directive.sharp)
		var lofs = directive.line.fullTextRegion.offset - node.totalOffset

		var substr = nodeStr.substring(sofs, lofs);
		var pattern = Pattern.compile("(\r|\n)")
		var matcher = pattern.matcher(substr)

		if(matcher.find) {
			error("extra new-line charactor is detected in C preprosessor directives.",
				CfgPackage.eINSTANCE.c_Directive_Line,
				EXTRA_NL_IN_CDIRECTIVE,
				fileStr.substring(sofs, lofs))
		}
	}

	@Check
	def checkNoExtraNewLineInCIncludeLine(C_IncludeLine line) {
		var d = line.eContainer as C_Directive
		var node = NodeModelUtils.getNode(d) as INode
		var text = node.text
		val incStr = "include"

		var sofs = text.indexOf(incStr)
		var nofs = text.indexOf(line.name)
		var substr = text.substring(sofs+incStr.length, nofs);
		var pattern = Pattern.compile("(\r|\n)")
		var matcher = pattern.matcher(substr)
		if(matcher.find) {
			error("extra new-line charactor is detected in C include lines.",
				CfgPackage.eINSTANCE.c_IncludeLine_Name,
				EXTRA_NL_IN_CINCLUDE,
				text.substring(6, nofs))
		}
	}

	@Check
	def checkNoExtraSpaceInCIncludeLineName(C_IncludeLine line) {
		var d = line.eContainer as C_Directive
		var node = NodeModelUtils.getNode(d) as INode
		var text = node.text

		var nofs = text.indexOf(line.name)
		var pattern = Pattern.compile("( |\t)")
		var matcher = pattern.matcher(line.name)
		if(matcher.find) {
			error("extra space or tab charactor is detected in header name.",
				CfgPackage.eINSTANCE.c_IncludeLine_Name,
				EXTRA_SPC_IN_CINCLUDE_NAME,
				text.substring(nofs, nofs+line.name.length()))
		}
	}
}
